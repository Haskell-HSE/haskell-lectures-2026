# Containers and traversable functors

```haskell
module L03_Containers where

import Control.Applicative (liftA2)
```

## Containers

As for any other programming language, there's a battle-tested library of data
structures for Haskell. Main difference is that, since Haskell is a pure
language, all of its data structures are necessarily immutable and, furthermore,
persistent: thanks to efficient garbage collector, persistence is obtained just
by reusing parts of older data structures in future allocations. A library of
these data structures is called, you guessed it, `containers` and is already a
part of system installation, just not exposed by default:

```
~ $ cabal install --lib containers
Error: [Cabal-7145]
Packages requested to install already exist in environment file at <path>/default. Overwriting them may break other packages. Use --force-reinstalls to proceed anyway. Packages: containers
```

Let's look what's
[inside](https://hackage-content.haskell.org/package/containers-0.8).

### Sets (and IntSet-s)

[Sets](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-Set.html)
are your usual, run-of-the-mill balanced binary trees based on ordering,
hence most operations require `Ord` constraint on the type of elements:

```haskell ignore
insert :: Ord a => a -> Set a -> Set a
```

Also note that sets are themselves `Ord` as long as their element type is `Ord`
as well. This allows us to nest sets: `Set (Set (Int, Int))`. Sets are also
monoids (with union being the chosen operation for `<>`) and `Foldable`s (with
elements folded from least to biggest, according to the chosen ordering).

[`IntSet`](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-IntSet.html)
is a specialised version of `Set` with more efficient allocation pattern and
more efficient tree layout &mdash; more precisely, they're not balanced binary
trees, but rather _big-endian patricia trees_ where each parent has much more
than just two children, allowing to have near-O(1) time complexity for its
operations.

### Maps (and IntMap-s)

[Maps](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-Map.html)
are, well, kay-value mappings with interface similar to the one of sets.
Once again, there's a
[specialised version](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-IntMap.html)
for integer keys; also there's another caveat to consider for maps, specifically
in Haskell context.

Since values (not keys) inside a map are not evaluated at all, they can be
stored unevaluated, in line with Haskell's lazy runtime; such definition is
specified in
[`Data.Map.Lazy`](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-Map-Lazy.html)/
[`Data.IntMap.Lazy`](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-IntMap-Lazy.html)
module (and just
[`Data.Map`](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-Map.html)/
[`Data.IntMap`](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-IntMap.html)
as well). However, due to performance reasons, you might want to immediately
force computations in order to store values themselves rather than thunks; for
this usecase Maps are also available, albeit `Strict` ones:
[`Data.Map.Strict`](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-Map-Strict.html),
[`Data.IntMap.Strict`](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-IntMap-Strict.html).

### Name clashing

With lots of similar types and operations having the same name (e.g. the very
`insert` above has siblings named exactly like him for `Map`s in all four
flavours etc.), it is inevitable for their names to clash in case you import
them in a regular way, bringing them into module scope. Instead, there's
helpful `qualified` import command:

```haskell
import Data.Map qualified as Map
import qualified Data.Map.Strict as StrictMap
import Data.Set qualified as Set

mapInsert :: Ord k => k -> a -> Map.Map k a -> Map.Map k a
mapInsert = Map.insert

strictMapInsert :: Ord k => k -> a -> StrictMap.Map k a -> StrictMap.Map k a
strictMapInsert = StrictMap.insert

setInsert :: Ord k => k -> Set.Set k -> Set.Set k
setInsert = Set.insert
```

The standard way to write `qualified` is just after `import` keyword, but
there's a GHC extension called `ImportQualifiedPost` which enables a more
human-readable way of writing.

### Other collections

Actually, there are yet some more collections in the package; we urge you to
explore them yourself. Also there's `unordered-containers` package for
hashing-based `Set`s and `Map`s, but it's less safe on unsanitized inputs due to
possible hash collision DoS attacks.

## (Traversable) functors

Met with such a zoo of different collection types, it is normal to start
wondering if there's a proper common abstraction for all of them. One would
think that this abstraction would concern itself with collection-like functions
like `insert`, `delete`, `expel`. Rather than that, it defines some very basic
primitives which are surprisingly useful. One of them is `Foldable`
which we've met before (as a quick reminder, this interface allows to compute
some common stats on top of data structures); next one is

### Functor

[Functor](https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Prelude.html#t:Functor)
typeclass captures the basic notion of capability to _map over elements_ of a
datatype.

```haskell ignore
class Functor (f :: Type -> Type) where
  fmap :: (a -> b) -> f a -> f b

instance Functor [] where
  fmap :: (a -> b) -> [a] -> [b]
  fmap = map
```

Some more examples to help capture an intuition:

```haskell
data Option a = Some a | None

instance Functor Option where -- instance Functor Maybe in base
  fmap _ None = None
  fmap f (Some x) = Some (f x)

data Result e a = Ok a | Err e

instance Functor (Result e) where -- instance Functor (Either e) in base
  fmap _ (Err e) = Err e
  fmap f (Ok x) = Ok (f x)

newtype Arrow a b = MkArrow { runArrow :: a -> b }

instance Functor (Arrow c) where -- instance Functor ((->) c) in base
  fmap f (MkArrow g) = MkArrow (f . g)
```

The Functor laws capture an important property that mapping over elements should
not change an overall internal structure of a container. In other words,

1. `fmap id x = x` (Identity);
2. `fmap g (fmap f x) = fmap (g . f) x` (Composition).

However, Functor laws are so strict that, if you can write out a lawful
instance for some type, every other possible lawful instance for it should
behave the same. GHC can derive such an instance automatically with the help of
`DeriveFunctor` language extension:

```haskell
data BinTree a = Leaf | Branch (BinTree a) a (BinTree a) deriving Functor
```

#### Functor non-examples

You might get the feeling that each generic type might be turned into a functor.
Yet there are two important counterexamples to consider, first one being

```haskell ignore
newtype FlipArrow a b = MkFlipArrow { runFlipArrow :: b -> a }

instance Functor (FlipArrow c) where
   fmap f (MkFlipArrow g) = MkFlipArrow ???
```

There's really nothing of worth we can substitute for `???` to pass the
typecheck since both `f` and `g` expect input of type `a`, but `???` is provided
only `b`s as input and has to return a `c`. Situation would change if
`f :: a -> b` were to have its type backwards (`b -> a`); this means that
function type is _contravariant_ in its argument type. In other words, `b` in
the type of `runFlipArrow` field is in a _negative position_. For something to
be a functor, its last generic parameter has to be in positive potitions only.

Another important example of a non-functor, surprisingly, is a Set. Consider a
hypothetical fmap:

```haskell ignore
fmap@Set :: (a -> b) -> Set a -> Set b
```

The problem is with the generality of a function argument. Since it can return
arbitrary `b`s for each `a`, it might not preserve the ordering of keys in a
set. There are two ways to deal with it: either restore an order using
[`map`](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-Set.html#v:map)

```haskell ignore
map :: Ord b => (a -> b) -> Set a -> Set b
```

Or assume that function argument is monotonic, namely, use
[`mapMonotonic`](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-Set.html#v:mapMonotonic)

```haskell ignore
mapMonotonic :: (a -> b) -> Set a -> Set b
```

First option does not fit into the signature of `Functor` since it works only on
linearly `Ord`ered `b`s while `Functor` should work on arbitrary ones.
Second one, while technically having the correct type, would break internal
invariants of a set when used with non-monotonic functions.

### Applicative

Actually, there are things more powerful than functors: applicative functors.

```haskell ignore
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
  liftA2 :: (a -> b -> c) -> f a -> f b -> f c
```

As notation and types are a little tricky, let us explain them bit by bit.

* At first sight, applicative functors can be seen as a generalization from
  lifting unary functions (`fmap`) to lifting functions of arbitrary arity:
  `pure x` is a lifting of an 0-ary function `x`; `liftA2` (read as lift
  applicative binary) lifts binary functions, and each and every `liftAN` can
  be written out in terms of `pure` and `(<*>)`:

```haskell ignore
liftA1 :: Applicative f => (a -> b) -> f a -> f b
liftA1 g fa = pure g <*> fa

(<$>) :: Applicative f => (a -> b) -> f a -> f b
(<$>) = liftA1

liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftA2 g fa fb = g <$> fa <*> fb

liftA3 ::
  Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
liftA3 g fa fb fc = g <$> fa <*> fb <*> fc
```

  Note that in doing so we showed that every applicative functor (that is,
  a type implementing `pure` and `(<*>)`) is a functor.

* On the other hand, applicative functor is a functor which can __apply__
  functions from inside of it via `(<*>)`, here's why it is called an
  __Applicative__.

* Third way to explain what's an `Applicative`: observe that it supports
  a granular, step-by-step embedding of algebraic data types inside it:
```haskell
unitA :: Applicative f => f ()
unitA = pure ()

pairA :: Applicative f => f a -> f b -> f (a, b)
pairA = liftA2 (,)

inLA :: Applicative f => f a -> f (Either a b)
inLA = fmap Left

inRA :: Applicative f => f b -> f (Either a b)
inRA = fmap Right

listA :: Applicative f => [f a] -> f [a]
listA [] = pure []
listA (x : xs) = (:) <$> x <*> listA xs
```
  So each `Applicative` can be viewed as some kind of a context in which data
  can be placed, with an empty context used in `pure` and a way to merge
  contexts in `(<*>)`. Hence there's something _monoidal_ about it; indeed,
  category theorists know applicatives under the name _monoidal functors_.

If `liftA2` can be implemented using `pure` and `(<*>)`, why is it included in
the class declaration? The reason for this is that `(<*>)` can be implemented
using `liftA2`:

```haskell ignore
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
(<*>) = liftA2 (\g x -> g x)
```

Applicative laws:

1. `pure id <*> v = v` (Identity);
2. `pure f <*> pure x = pure (v x)` (Homomorphism);
3. `u <*> pure y = pure (\f -> f y) <*> u` (Interchange);
4. `u <*> (v <*> w) = ((pure (.) <*> u) <*> v) <*> w` (Composition);
5. `liftA2 g u v = pure g <*> u <*> v` (relation with `liftA2`);
6. `fmap = liftA1` (relation with Functor).

Intuitively:

* `pure` must not provide any additional information meaningful to `(<*>)` (so
  here's the source of the name: it should encapsulate a __pure__ value and do
  nothing more);
* the merging of internal structure performed in `(<*>)` should be associative.

Some examples to help capture an intuition:

```haskell
instance Applicative Option where
  pure = Some
  Some f <*> x = fmap f x
  None <*> _ = None

instance Applicative (Result e) where
  pure = Ok
  Ok f <*> x = fmap f x
  Err e <*> _ = Err e

instance Applicative (Arrow c) where
  pure x = MkArrow (const x)
  MkArrow f <*> MkArrow g = MkArrow $ \c -> f c (g c)
```

I advise you to spend some time trying to understand what these instances do in
expressions like `f <$> a <*> b <*> c <*> d` to capture their meaning.

#### Two Applicative instances for lists

When writing out an instance of applicative for lists, we have to provide two
functions:

```haskell ignore
pure@List :: a -> [a]
(<*>)@List :: [a -> b] -> [a] -> [b]
```

1. For `pure x`, there are infinitely many options which pass the typecheck and
  do not fail in runtime: `[]`, `[x]`, `[x, x]`, `[x, x, x]`, ..., `repeat x`.
  Gut feeling should tell you that only three of them look sensible: `[]`, `[x]`
  and `repeat x`.

2. For `fs <*> xs`, there's two sensible things to do:
  * apply functions to arguments pointwise, e.g.
    `[f, g, h] <*> [a, b, c] = [f a, g b, h c]`;
  * try all options in cartesian product fashion, namely
    `[f, g, h] <*> [a, b] = [f a, f b, g a, g b, h a, h b]`.

Among possible combinations of `pure` and `<*>` from above, there are two lawful
combinations:

```haskell ignore
-- Option 1
instance Applicative [] where
  pure x = [x]
  [] <*> _ = []
  (f:fs) <*> xs = fmap f xs ++ (fs <*> xs)

-- Option 2
instance Applicative [] where
  pure x = go where go = x : go
  (<*>) = zipWith ($)
```

We've told you before that in cases like that, rather than choosing one of the
instances, Haskellers usually define newtypes for each instance. However, in
this case, there _is_ an `instance Applicative []`, and it's the first option
above (for the second option, there's a
[ZipList](https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Control-Applicative.html#t:ZipList)
newtype). So it ought to be better in some sense, right? We're going to find in
the next lecture!

### Traversable

How to generalize `Functor`s which are at the same time `Foldable`? Enter
`Traversable`:

```haskell ignore
class (Functor t, Foldable t) => Traversable t where
    {-# MINIMAL traverse | sequenceA #-}
    traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
    sequenceA :: Applicative f => t (f a) -> f (t a)
```

It is a generalization of `Functor` in the sense that it allows mapping over
elements of `t` with some kind of a "side-effect" `f`; `f` has to be an
`Applicative` in order to merge the results from different parts of `t`.

It is a generalization of `Foldable` in the sense that it allows both to record
some statistic in context `f` AND keep the structure of `t`;
`f` has to be an `Applicative` in order to merge the results from different
parts of `t`.

By the way, all three of `Functor`, `Foldable` and `Traversable` are derivable
by GHC with the help of appropriate language extensions.

To get familiar with `Traversable`, in addition to the homework given out to you,
it might be fun instantiating both `t` and `f` to `[]` in order to see what happens.

#### Foldable functors, but not traversables?

It might look like Traversables are a conservative generalization in the sense
that each `Foldable` `Functor` is also a `Traversable`; regrettably, it isn't
so. Consider the following datatype:

```haskell
data Bunch a b = MkBunch (Set.Set a) (a -> b) deriving Functor
```

In the sense, it is a set along with a function to later apply to its elements.
It is evidently a `Functor`; it can be made into `Foldable` as well:

```haskell
instance Foldable (Bunch a) where
  foldMap f (MkBunch xs g) = foldMap (f . g) xs
```

However, it is impossible to write down a `Traversable` instance.

## Sources

* [Thorough guide on ubiquitous Haskell typeclasses](https://wiki.haskell.org/Typeclassopedia)
