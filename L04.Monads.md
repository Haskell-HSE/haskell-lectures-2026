# Monads

```haskell
{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE DerivingStrategies #-}

module L04_Monads where

import Prelude hiding (Either (..), Maybe (..))
```

> Monad is a monoid in category of endofunctors.
<p align="right">&mdash; Correct, but absolutely useless definition</p>

> Monads are like burritos.
<p align="right">&mdash; https://blog.plover.com/prog/burritos.html</p>

(Actually no, please read
[this link](https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/)
instead.)

> `>>=` is a programmable `;`.
<p align="right">&mdash; Haskell folklore</p>

## Interface

Now, the most notable typeclass of all is a
[`Monad`](https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Prelude.html#t:Monad).
What is this?

```haskell ignore
class Applicative m => Monad m where
  return :: a -> m a
  return = pure

  (>>=) :: m a -> (a -> m b) -> m b

  (>>) :: m a -> m b -> m b
  mx >> my = mx >>= (\_ -> my)
```

This is an interface most useful to express effectful operations: `return x` is
a pure result of otherwise effectful computation; `(>>=)` and `(>>)` both
execute operations in order, where in `(>>=)` (also called "bind") (in other
languages called `then`, `and_then`, `flatMap`,...) a second computation can
depend on the outcome of the first.

## Monad laws

1. `return a >>= k = k a` (Left identity);
2. `m >>= return = m` (Right identity);
3. `(m >>= k) >>= h = m >>= (\x -> k x >>= h)` (Associativity).

After squinting a little, this looks like monoid laws. With additional
technical work, Monad actually looks like a proper "monoid in the category of
endofunctors", whatever this category-theoretic talk means. However, you do not
need this arcane knowledge to program in Haskell: just learn the laws and the
interface itself.

## Monad as a subclass of Applicative

Turns out that `Monad` is a proper subclass of
[`Applicative`](https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Prelude.html#t:Applicative),
meaning that lawful `(<*>)` can be written out in terms of lawful `return` and
`(>>=)`:

```haskell
ap :: Monad m => m (a -> b) -> m a -> m b
ap mf mx = mf >>= \f -> mx >>= \x -> return (f x)
```

(This is already defined in standard library, in module
[`Control.Monad`](https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Control-Monad.html#v:ap).
Don't be afraid to use Hoogle to find such combinators!)

## Instances

It is hard to grasp an abstraction without seeing concrete examples first, so
let's go over some of the more useful Monad instances.

### Partial computations

Not really a partial function:

```haskell
throw :: a
throw = error "ERROR!!!"
```

We wish to be able to catch errors, provide substitutes, etc...

An already familiar friend comes to the rescue, now with a `Monad` instance:

```haskell
data Maybe a = Just a | Nothing deriving Functor

instance Applicative Maybe where
  pure = Just
  (<*>) = ap

instance Monad Maybe where
  (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
  Just x >>= f = f x
  Nothing >>= _ = Nothing
```

Then, partial functions turn out to be nothing more but functions which return a
`Maybe`:

```haskell
type Partial a b = a -> Maybe b

safeDiv :: Integral a => a -> a -> Maybe a
safeDiv _ 0 = Nothing
safeDiv x y = Just (x `div` y)
```

However, there's a little problem when stitching partial functions defined like
this together. Imagine an algorithm where we safely divide `x` by `x - 1` to get
`d`, and then safely divide `d` by `d + 1` and return all intermediate results.
Translated into Haskell, this would look like this:

```haskell
algo :: Integral a => a -> Maybe (a, a)
algo x =
  safeDiv x (x - 1)
    >>= ( \d ->
            safeDiv d (d + 1)
              >>= ( \e ->
                      pure (d, e)
                  )
        )
```

Ah, the dreaded Callback Hell. To save us from it, there's a special builtin
syntax sugar for Monads called "do-notation". Name is self-explanatory:

```haskell
algo' :: Integral a => a -> Maybe (a, a)
algo' x = do             -- in Rust it would be:
  d <- safeDiv x (x - 1) -- let d = safeDiv(x, x - 1)?;
  e <- safeDiv d (d + 1) -- let e = safeDiv(d, d + 1)?;
  pure (d, e)            -- Some((d, e))
```

### Computations which throw on errors

Also a familiar one. Let's record the reasons for failure; what do we get?

```haskell
data Either e a = Left e | Right a deriving Functor

instance Applicative (Either e) where
  pure = Right
  (<*>) = ap

instance Monad (Either e) where
  (>>=) :: Either e a -> (a -> Either e b) -> Either e b
  Left e >>= _ = Left e
  Right x >>= f = f x
```

Unfold the definition of `ap` for `Either` to know how errors are collected and
get propagated.

### Computations which interact with runtime system

Enter `IO`, also called the "dumpster of side-effects":

```haskell
main :: IO ()
main = do
  putStr "Please tell me your name: "
  name <- getLine
  putStrLn ("Hello, " <> name <> "!")
```

`IO` in a signature of a function tells that this function messes with the
runtime in some way: file I/O, POSIX terminal settings, system calls, FFI,
settings of the Haskell runtime itself, basic synchronization primitives etc.

### Computations with access to readonly environment

Hey, we've seen that one: functions are applicatives.
Also monads (what a surprise):

```haskell
newtype Reader e a = Reader {runReader :: e -> a}
  deriving newtype (Functor, Applicative)

instance Monad (Reader e) where
  Reader f >>= k = Reader \e -> runReader (k (f e)) e

ask :: Reader e e
ask = Reader id
```

From side-effects viewpoint, monad instance for functions captures the
capability of a computation to access some readonly environment.

### Computations which write to the log

If there's readonly, there should also be write-only capability:

```haskell
data Writer l a = Writer { writerLog :: l, writerResult :: a }
  deriving Functor

instance Monoid l => Applicative (Writer l) where
  pure = Writer mempty
  (<*>) = ap

instance Monoid l => Monad (Writer l) where
  Writer l x >>= k = let Writer l' y = k x in Writer (l <> l') y

tell :: l -> Writer l ()
tell l = Writer l ()

loggable :: (Show a, Show b) => (a -> b) -> a -> Writer [String] b
loggable f x = do
  tell ["Starting...", "got x = " <> show x]
  let y = f x
  tell ["Stopping...", "computed y = " <> show y]
  pure y
```

We could compose logs backwards (`l' <> l`) and also get a lawful instance, but
natural order is more intuitive. In addition, backwards composition is still
recoverable (how?).

Note that this Monad is available as instance on tuples (look for
`instance Monoid a => Monad ((,) a)` instance on Hackage).

### Stateful computations

Providing both read- and write- capabilities, we get stateful computation:

```haskell
newtype State s a = State {runState :: s -> (a, s)}
  deriving Functor

instance Applicative (State s) where
  pure x = State \s -> (x, s)
  (<*>) = ap

instance Monad (State s) where
  (>>=) :: State s a -> (a -> State s b) -> State s b
  State mx >>= clb = State \s0 -> let (x, s1) = mx s0 in runState (clb x) s1

get :: State s s
get = State \s -> (s, s)

set :: s -> State s ()
set s' = State \_ -> ((), s')
```

This means that we, as all computer scientists, can create our own off-by-one
errors for ourselves:

```haskell
increment :: State Int ()
increment = do
  cnt <- get
  set (cnt + 1)
  pure ()
```

Fun fact: if you look at the definition of `(>>=)` closely, you can make state
flow backwards in time (with help of Haskell's laziness, of course). Consult
[this package](https://hackage.haskell.org/package/tardis) for details.
([Why would anyone need that?](https://wiki.haskell.org/index.php?title=Tying_the_Knot))

### Doing nothing, identically

We weren't functional programmers if we didn't do useless stuff. Here's an
example of a monad which doesn't produce any side effects:

```haskell
newtype Identity a = Identity {runIdentity :: a}

instance Functor Identity where
  fmap f (Identity x) = Identity (f x)

instance Applicative Identity where
  pure = Identity
  Identity f <*> Identity x = Identity (f x)

instance Monad Identity where
  Identity x >>= f = f x
```

I mean, it's only useful when you want to run a computation which is generalized
over an arbitrary `Monad m`, but there are no side effects you wish to produce.
(But if you like Go, you can just rewrite this computation from scratch without
`Monad m` constraint, of course)

### Doing everything, everywhere, all at once

Monad instance for lists might be the most familiar to you if you know how
`.flatMap` works. Or how `::flat_map` works. Or how... you get it:

```haskell
data List a = Nil | Cons a (List a) deriving Functor

instance Semigroup (List a) where
  Nil <> xs = xs
  Cons x xs <> ys = Cons x (xs <> ys)

instance Applicative List where
  pure = (`Cons` Nil)
  (<*>) = ap

instance Monad List where
  (>>=) :: List a -> (a -> List b) -> List b
  Nil >>= _ = Nil
  Cons x xs >>= f = f x <> (xs >>= f)
```

Once again, unfold definition of `ap` for lists to finally settle which one of
the two applicative instances for lists is The True One.

Actually, let's stop here for a second.

```haskell
comprehension :: [Int]
comprehension = [ x + y | x <- [1..100], y <- [-x..x] ]

doNotation :: [Int]
doNotation = do
  x <- [1 .. 100]
  y <- [-x .. x]
  pure (x + y)
```

![They're the same picture](https://tenor.com/bzgav.gif)

## Monad non-instances

The picture would be incomplete without ever-so-slightly gotchas. Here are some
examples of (very useful!) applicatives which aren't monads.

### Computations with accumulation of errors

In Homework #3, we have a type which looks like `Either`, but instead of
stopping on first error, it tries to accumulate them.

```haskell
data ErrAccum e a = ELeft e | ERight a
  deriving Functor

instance Semigroup e => Applicative (ErrAccum e) where
  pure = error "Your homework, buddy"
  (<*>) = error "Your homework, buddy"
```

If we try to write a `Monad` instance for it, however, the only sensible
instance we can write is the same as the one for `Either`:

```haskell
instance Semigroup e => Monad (ErrAccum e) where
  ELeft e >>= _ = ELeft e
  ERight a >>= k = k a
```

Unfortunately, it doesn't satisfy monad laws. Can you tell why?

### Doing nothing, constantly

Another useless functor which completely ignores its argument and stores
something else entirely inside:

```haskell
newtype Const a b = Const {runConst :: a}
  deriving (Functor)

instance Monoid a => Applicative (Const a) where
  pure :: b -> Const a b
  pure _ = Const mempty

  (<*>) :: Const a (b -> c) -> Const a b -> Const a c
  Const m <*> Const n = Const (m <> n)

instance Monoid a => Monad (Const a) where
  Const m >>= _ = Const m
```

What's wrong with these instances?

### Zipping stuff

Recall The False instance of Applicative for lists:

```haskell
newtype ZipList a = ZipList {runZipList :: [a]} deriving Functor

instance Applicative ZipList where
  pure = ZipList . repeat
  ZipList fs <*> ZipList xs = ZipList (zipWith ($) fs xs)
```

Let's try to figure out what could be a lawful `Monad` instance for it.

```haskell ignore
instance Monad ZipList where
  (>>=) = ???
```
