# Typeclasses

Typeclasses are one way Haskell does polymorphism. They are similar to
interfaces in other languages: a typeclass defines a set of functions that must
work on any type that is in that typeclass.

The
[Eq](https://hackage.haskell.org/package/base-4.19.0.0/docs/Prelude.html#t:Eq)
typeclass is for types whose instances can be tested for equality with one
another.

```haskell ignore
class Eq a where
    {-# MINIMAL (==) | (/=) #-}
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    x == y = not (x /= y)
    x /= y = not (x == y)
```

This defines a typeclass that requires two functions, `(==)` and `(/=)`. It also
declares that one function can be declared in terms of another, so it is enough
that __either__ the `(==)` function or the `(/=)` is defined and the other will
be "filled in" based on the typeclass definition.

To make a type a member of a type class, the `instance` keyword is used

```haskell
data TrafficLight = TLRed | TLYellow | TLGreen

instance Eq TrafficLight where
    TLRed == TLRed = True
    TLGreen == TLGreen = True
    TLYellow == TLYellow = True
    _ == _ = False
```

Now we can use `(==)` and `(/=)` with `TrafficLight` objects:

```haskell
canProceedThrough :: TrafficLight -> Bool
canProceedThrough t = t /= TLRed
```

Functions can be written to take typeclasses with type parameters, rather than
types, assuming that the function only relies on features of the typeclass:

```haskell
isEqual :: Eq a => a -> a -> Bool
isEqual x y = x == y
```

Note that `x` and `y` MUST be the same type, as they are both defined as being
of type parameter `a`. A typeclass does not state that different types in the
typeclass can be mixed together. So `isEqual Red 2` is invalid even though `2`
is an `Int` which is an instance of `Eq`, and `Red` is a `TrafficLight` which is
also an instance of `Eq`.

Other common typeclasses are:

* `Ord` for types that can be ordered, allowing you to use `>`, `<=`, etc.
* `Read` for types that can be created from a string representation
* `Show` for types that can be converted to a string for display
* `Num`, `Real`, `Integral`, `Fractional` for types that can do math
* `Enum` for types that can be stepped through
* `Bounded` for types with maximal and minimal value

## Literals

We used character, string and list literals back from the very start. It is
simple to understand what they mean and how to use them. However, numeric
literals are not so simple. If we ask GHCi: "what is the type of 2?", we get:

```
ghci> :t 2
2 :: Num a => a
```

So numeric literals are actually polymorphic and do not have a concrete type.
Not that this is not the same as casts because the following is not allowed:

```haskell
two = 2 :: Integer
```
```haskell ignore
float = two * 0.5 -- would not pass the type check
```

## Deriving

Haskell can automatically make types part of `Eq`, `Ord`, `Read`, `Show`, `Enum`
and `Bounded` with the `deriving` keyword at the end of the type declaration

```haskell
data PointDerives = Point Float Float deriving (Eq, Read, Show)
```

In this case you do NOT need to create an `instance` definition.

## Monoids

One of the more abstract typeclasses is
[Monoid](https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Prelude.html#t:Monoid)
together with its superclass,
[Semigroup](https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Prelude.html#t:Semigroup).

```haskell ignore
class Semigroup a where
    (<>) :: a -> a -> a
    sconcat :: NonEmpty a -> a
    stimes :: Integral b => b -> a -> a
    {-# MINIMAL (<>) | sconcat #-}

class Semigroup a => Monoid a where
    mempty :: a
    mappend :: a -> a -> a
    mappend = (<>)
    mconcat :: [a] -> a
    {-# MINIMAL mempty | mconcat #-}
```

Essentially, a monoid is a type for which there's a `(<>)` which ought to be a
binary associative operation and a `mempty` which ought to be a neutral element
for `(<>)`. This definition might seem too abstract to be useful, but actually
it nicely captures a notion of "statistic" or "aggregated result" you might want
to retrieve from a datastructure: `mempty` is a statistic of an empty
datastructure, and `(<>)` defines a way to merge two statistics together.

Simplest statistic you might want to come up with is, of course,
[Sum](https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Data-Monoid.html#t:Sum):

```haskell
newtype Sum a = Sum { getSum :: a }

instance Num a => Semigroup (Sum a) where
    (<>) = coerce ((+) :: a -> a -> a)
    stimes n (Sum a) = Sum (fromIntegral n * a)

instance Num a => Monoid (Sum a) where
    mempty = Sum 0
    mconcat = List.foldl' (<>) mempty
```

You might want to aggregate a product instead, guess what it's called.

Also you might want to aggregate two statistics at the same time:

```haskell ignore
instance (Semigroup a, Semigroup b) => Semigroup (a, b) where
    (a, b) <> (a', b') = (a <> a', b <> b')
    stimes n (a, b) = (stimes n a, stimes n b)

instance (Monoid a, Monoid b) => Monoid (a,b) where
    mempty = (mempty, mempty)
```

To lookup available instances for a typeclass, you can either take a look at its
Haddock documentation (here's for
[Monoid](https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Prelude.html#t:Monoid))
or type `:i <typeclass>` into GHCi:

```
~ $ ghci
Loaded package environment from /home/turtle/.ghc/x86_64-linux-9.12.2/environments/default
GHCi, version 9.12.2: https://www.haskell.org/ghc/  :? for help
ghci> :i Monoid
type Monoid :: * -> Constraint
class Semigroup a => Monoid a where
  mempty :: a
  mappend :: a -> a -> a
  mconcat :: [a] -> a
  {-# MINIMAL mempty | mconcat #-}
        -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
instance Monoid b => Monoid (a -> b)
  -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
instance Monoid a => Monoid (IO a)
  -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
instance Monoid [a]
  -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
instance Semigroup a => Monoid (Maybe a)
  -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
instance Monoid Ordering
  -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
instance Monoid a => Monoid (Solo a)
  -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
instance (Monoid a, Monoid b) => Monoid (a, b)
  -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
instance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)
  -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
instance (Monoid a, Monoid b, Monoid c, Monoid d) =>
         Monoid (a, b, c, d)
  -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
instance (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>
         Monoid (a, b, c, d, e)
  -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
instance Monoid ()
  -- Defined in ‘ghc-internal-9.1202.0:GHC.Internal.Base’
```

## Typeclass laws

Sometimes, good documentation of an interface explicitly describes a set of
invariants any implementation should uphold; in the case of Haskell, it
is a common rule of good manners to provide _typeclass laws_ for any typeclass
you define. For example, documentation for `Semigroup` and `Monoid` classes from
Haskell's standard library is written like this:

```haskell ignore
-- | The class of semigroups (types with an associative binary operation).
--
-- Instances should satisfy the following:
--
-- [Associativity] @x '<>' (y '<>' z) = (x '<>' y) '<>' z@
class Semigroup a where
        -- | An associative operation.
        --
        -- >>> [1,2,3] <> [4,5,6]
        -- [1,2,3,4,5,6]
        (<>) :: a -> a -> a

-- | The class of monoids (types with an associative binary operation that
-- has an identity). Instances should satisfy the following:
--
-- [Right identity] @x '<>' 'mempty' = x@
-- [Left identity]  @'mempty' '<>' x = x@
class Semigroup a => Monoid a where
        -- | Identity of '<>'
        --
        -- >>> "Hello world" <> mempty
        -- "Hello world"
        mempty :: a
```

An instance of a typeclass which abides its laws is called a "lawful instance".
While nothing stops you from making a non-lawful instance, you should
nevertheless try to make your instances lawful because typeclass laws usually
capture an important intuition about an interaction between operations inside a
class: for example, we can safely omit parentheses while working with a lawful
semigroup instance, but with non-lawful instance we cannot.

## Higher-kinded types

Typeclasses are actually more powerful than their counterparts in other
languages. Most notably, we can define typeclasses which describe an interface
of a generic type instead of a concrete type. For example, a
[Foldable](https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Prelude.html#t:Foldable)
class describes a type of generic collections whose contents can be folded with
a monoid operation:

```haskell ignore
class Foldable t where
    {-# MINIMAL foldMap | foldr #-}
    fold :: Monoid m => t m -> m
    foldMap :: Monoid m => (a -> m) -> t a -> m
    foldMap' :: Monoid m => (a -> m) -> t a -> m
    foldr :: (a -> b -> b) -> b -> t a -> b
    foldr' :: (a -> b -> b) -> b -> t a -> b
    foldl :: (b -> a -> b) -> b -> t a -> b
    foldl' :: (b -> a -> b) -> b -> t a -> b
    foldr1 :: (a -> a -> a) -> t a -> a
    foldl1 :: (a -> a -> a) -> t a -> a
    toList :: t a -> [a]
    null :: t a -> Bool
    length :: t a -> Int
    elem :: Eq a => a -> t a -> Bool
    maximum :: forall a . Ord a => t a -> a
    minimum :: forall a . Ord a => t a -> a
    sum :: Num a => t a -> a
    product :: Num a => t a -> a
```

The Jacque Fresco Riddle: how is `foldr` implemented in terms of `foldMap`?
